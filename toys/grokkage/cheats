7/18/2024 09:27:44 AM     D:\dev\code\toys\grokkage\cheats

------------------count bits in x ------------------------------------------
    int cnt = 0; while (x) { cnt++; x &= (x-1); }
------------------insert sort-----------------------------------------------
void insort(int a[], int n) {
    for (int i = 1 ; i < n; i++) {
        int j = i;
        while (j > 0 && a[j] < a[j-1]) {
            int t = a[j];
            a[j] = a[j-1];
            a[j-1] = t;
            j--;
        }
    }
}
------------------list reverse ---------------------------------------------
p=list,q,r=null         while (p)           usage: returns pure headless list
                            q = p->next; p->next = r; r = p; p = q
                        return r
------------------max heap---------------------------------------------------
heap[256]; heap[0] = INT_MAX; size=0; ins: loop(a): heap[++size] = a[i]; up(size);
pop: while(size): max = heap[1]; heap[1] = heap[size--]; down(1); print(max);
                           down(k):
up(k):                          last = [k]
    v = [k]                     while k <= size/2:
    while [k/2] <= v:               child = 2k
        [k] = [k/2]                 if child < size && 
        k = k/2                       [child] < [child+1]:
    [k] = v                             child++
                                    if last >= [child] break
                                    [k] = [child]
                                    k = child
                                [k] = last
------------------trie------------------------------------------------------
void insert(ROOT R, KEY)              bool find(ROOT R, KEY)
    foreach k in KEY:                   foreach k in KEY:
        if R->m[k-'a'] == NULL              if R->m[k-'a'] == NULL return FALSE
            R->m[k-'a'] = NEW               R = R->m[k-'a']
        R = R->m[k-'a'] // next R       if R->m[TERM] == NULL return FALSE
    R->m[TERM] = NEW                    return TRUE
-------------------ring-----------------------------------------------------
void put(x)                         int get()           MAX = 2^n
    if (!full())                        x = [tail]
        [head] = x                      tail = (tail+1)%MAX
        head = (head+1)%MAX             size--
        size++;                         return x
int data() return size              int space() return MAX-size
-----------------------tree-------------------------------------------------
void ins(TREE **T, X)               void bfs(TREE)
if (*T == NULL) *T = NEW            PUT(T, Q)
elseif (X < T->x) ins(T->LEFT, X)   while (!empty(Q))
elseif (X > T->x) ins(T->RIGHT, X)      N = GET(); PROCESS(N)
                                        if (N->LEFT)  PUT(N->LEFT, Q)
                                        if (N->RIGHT) PUT(N->RIGHT, Q)
----------------------------------------------------------------------------
endian: uint32 x = 0x11223344L; (H->L), char *p = &x; loop: p[i] addrs increase
----------------------------------------------------------------------------
int binsearch(int *s, int n, char k) {
    int low=0, high=n-1, mid;
    while (low <= high) {
        mid = (low+high)/2;
        if (k > s[mid]) low = mid + 1;
        else if (k < s[mid]) high = mid - 1;
        else return k;
    }
    return -1;
}
----------------------------------------------------------------------------
fifo: list & array
hash

